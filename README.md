# Virtual_Shopping_System
Single Threading, Multi-Threading and some advanced concepts in Java

# Use Case Scenario
We want to implement a virtual shopping system, whether the threads are either clients using the web app or clients buying products on the physical shop using the mobile app. The lifecycle of any client interaction is summarised by ClientLifecycle: Each client interacts with the shop through the RainforestShop via the login method, through which each client can add items to its basket and perform re-shelving operations (moving the items back to the physical/virtual shelf from the basket). Each client can get a list of available items at the time of the query, basket a given product by name, (re)shelf the product (thus removing it from the basket), checkout and proceed with the payment (thus either buying all the items on the basket or none of those entirely), and logging out of the system while losing the information of all the items being previously put in the basket from the real/virtual shelf (thus entailing implicit re-shelving). Each time an allowed user logs in, a non-empty transaction will be created with an unique transaction ID. The unavailability of the product shall be confirmed not while basketing the items, rather than after purchasing those. At this stage, the shop supplier (SupplierLifecycle) might be notified that some products are missing (getNextMissingItem) and refurbish the show with a non-zero amount of products of the same type (refurbishWithItems). For simplicity's sake, the refurbishWithItems method will be in charge of creating the number of desired product and placing them on the shelf. As in any industrial setting where teams split up the duties, you are assigned an API that you need to implement. This will then require finalising the implementation of RainforestShop and the integration of concurrency mechanisms in ProductMonitor; the Transaction class shall not be changed! The Testing solves a twofold task: showing how Clients, Suppliers, and the Shop system are communicating, as well as providing some preliminary guidelines on how the coursework is going to be assessed. The student is free to choose whichever is the best way to pass the tests (not fully disclosed to the students) in the Testing class. E.g., the RainforestShop could be modelled as a finer-grained monitor, but inside this monitor at least one thread per logged user should be running; also, such a RainforestShop could be implemented as consumer threads handling all of the client’s messages.

# Assumptions
• In a realistic example, communications happen between processes via UDP messages. In this module, we don’t require that. We can freely assume that each client (Physical person buying items in the show using the mobile app, OnLine Shopper) is mimicked by one single thread. We assume they directly exploit such an interface (no FrontEnd is required!)

• If the RainforestShop is implemented as a server, such a thread might receive the “client messages” through shared variables.

• The RainforestShop already comes with a Transaction class keeping track of the transactions that are performed for handling basketing operations. You are not required to tolerate the server crash (this is more of a backup task rather than a concurrent programming one), but you must correctly handle client logouts (withdrawn items from the shelves after log-out should be automatically re-shelved with a cookie-free assumption, where the basket is not “remembered” after re-logging in)!

• We assume that the RainforestShop class is initialized with the users allowed to shop using the mobile app or online website (Collection<String> client_ids), the association between the name of the product (String), its cost (Double) and a non-zero Integer number of available items to purchase (Map<String, Pair<Double, Integer» available_products). The system should not allow to register/unroll new users/shoppers.

• The server should allow a single user contemporarily log in with the same username as far as different transaction IDs are given to distinguish different concurrent operations. In order
to maximise seriality and concurrency requirements, the students might investigate optimistic protocols for transactions, but this is not strictly required.




